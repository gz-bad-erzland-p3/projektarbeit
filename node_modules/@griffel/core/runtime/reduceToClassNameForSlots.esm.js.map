{"version":3,"file":"reduceToClassNameForSlots.esm.js","sources":["../../../../packages/core/src/runtime/reduceToClassNameForSlots.ts"],"sourcesContent":["import { DEFINITION_LOOKUP_TABLE } from '../constants';\nimport { hashSequence } from './utils/hashSequence';\nimport { CSSClassesMapBySlot, CSSClassesMap, CSSClasses } from '../types';\n\n/**\n * Reduces a classname map for slot to a classname string. Uses classnames according to text directions.\n *\n * @private\n */\nexport function reduceToClassName(classMap: CSSClassesMap, dir: 'ltr' | 'rtl'): string {\n  let className = '';\n\n  // eslint-disable-next-line guard-for-in\n  for (const propertyHash in classMap) {\n    const classNameMapping: CSSClasses = classMap[propertyHash];\n\n    if (classNameMapping) {\n      const hasRTLClassName = Array.isArray(classNameMapping);\n\n      if (dir === 'rtl') {\n        className += (hasRTLClassName ? classNameMapping[1] : classNameMapping) + ' ';\n      } else {\n        className += (hasRTLClassName ? classNameMapping[0] : classNameMapping) + ' ';\n      }\n    }\n  }\n\n  return className.slice(0, -1);\n}\n\n/**\n * Reduces classname maps for slots to classname strings. Registers them in a definition cache to be used by\n * `mergeClasses()`.\n *\n * @internal\n */\nexport function reduceToClassNameForSlots<Slots extends string | number>(\n  classesMapBySlot: CSSClassesMapBySlot<Slots>,\n  dir: 'ltr' | 'rtl',\n): Record<Slots, string> {\n  const classNamesForSlots = {} as Record<Slots, string>;\n\n  // eslint-disable-next-line guard-for-in\n  for (const slotName in classesMapBySlot) {\n    const slotClasses = reduceToClassName(classesMapBySlot[slotName], dir);\n\n    // Handles a case when there are no classes in a set i.e. \"makeStyles({ root: {} })\"\n    if (slotClasses === '') {\n      classNamesForSlots[slotName] = '';\n      continue;\n    }\n\n    const sequenceHash = hashSequence(slotClasses, dir);\n    const resultSlotClasses = sequenceHash + ' ' + slotClasses;\n\n    DEFINITION_LOOKUP_TABLE[sequenceHash] = [classesMapBySlot[slotName], dir];\n    classNamesForSlots[slotName] = resultSlotClasses;\n  }\n\n  return classNamesForSlots;\n}\n"],"names":["reduceToClassName","classMap","dir","className","propertyHash","classNameMapping","hasRTLClassName","Array","isArray","slice","reduceToClassNameForSlots","classesMapBySlot","classNamesForSlots","slotName","slotClasses","sequenceHash","hashSequence","resultSlotClasses","DEFINITION_LOOKUP_TABLE"],"mappings":";;;AAIA;;;;;;SAKgBA,kBAAkBC,UAAyBC;EACzD,IAAIC,SAAS,GAAG,EAAhB;;EAGA,KAAK,MAAMC,YAAX,IAA2BH,QAA3B,EAAqC;IACnC,MAAMI,gBAAgB,GAAeJ,QAAQ,CAACG,YAAD,CAA7C;;IAEA,IAAIC,gBAAJ,EAAsB;MACpB,MAAMC,eAAe,GAAGC,KAAK,CAACC,OAAN,CAAcH,gBAAd,CAAxB;;MAEA,IAAIH,GAAG,KAAK,KAAZ,EAAmB;QACjBC,SAAS,IAAI,CAACG,eAAe,GAAGD,gBAAgB,CAAC,CAAD,CAAnB,GAAyBA,gBAAzC,IAA6D,GAA1E;OADF,MAEO;QACLF,SAAS,IAAI,CAACG,eAAe,GAAGD,gBAAgB,CAAC,CAAD,CAAnB,GAAyBA,gBAAzC,IAA6D,GAA1E;;;;;EAKN,OAAOF,SAAS,CAACM,KAAV,CAAgB,CAAhB,EAAmB,CAAC,CAApB,CAAP;AACD;AAED;;;;;;;SAMgBC,0BACdC,kBACAT;EAEA,MAAMU,kBAAkB,GAAG,EAA3B;;EAGA,KAAK,MAAMC,QAAX,IAAuBF,gBAAvB,EAAyC;IACvC,MAAMG,WAAW,GAAGd,iBAAiB,CAACW,gBAAgB,CAACE,QAAD,CAAjB,EAA6BX,GAA7B,CAArC,CADuC;;IAIvC,IAAIY,WAAW,KAAK,EAApB,EAAwB;MACtBF,kBAAkB,CAACC,QAAD,CAAlB,GAA+B,EAA/B;MACA;;;IAGF,MAAME,YAAY,GAAGC,YAAY,CAACF,WAAD,EAAcZ,GAAd,CAAjC;IACA,MAAMe,iBAAiB,GAAGF,YAAY,GAAG,GAAf,GAAqBD,WAA/C;IAEAI,uBAAuB,CAACH,YAAD,CAAvB,GAAwC,CAACJ,gBAAgB,CAACE,QAAD,CAAjB,EAA6BX,GAA7B,CAAxC;IACAU,kBAAkB,CAACC,QAAD,CAAlB,GAA+BI,iBAA/B;;;EAGF,OAAOL,kBAAP;AACD;;;;"}